# Extra notes

## Asssertions

An assertion in the context of contract programming or data verification my be synonimous
with check, property or even a test.

When the assertion works as desired we continue with the flow of data, otherwise when data
fails to comply to the assertion we "fail" the process.

There are many mechanisms that may mimick assertions in elixir, some of them are more cathered 
towards program flow but all may be composed into assertions:

* Raising an error with `raise "message"` or `raise CustomExceptionError`
* Returning an `:error` atom or an `{:error, "message"}` tuple.
* Returning a structure `CustomError` or exception structure `CustomExceptionError` as data.
* Using the `assert` keyword through the `ExUnit` test framework.

There are as well many mechanisms for control flow which will aid us in error handling,
while the point of an assertion is not necessarily to introduce control flow, these
will help us to build complex functionality:

* Pattern matching on data with multiple shapes `case` or function headers.
* Using predicates along the `if` and `cond` macros.
* Composition of complex return values via the `with` clause macro.
* Error handling via the `try` clause or the `rescue` keyword at the function level.
* Error handling through processes signals.

Note, this tutorial is not meant to teach or offer advise on how to use the above constructs;
the real semantics of the above may have other roots but this series tries to exploit them 
in a way that works along the Contract Programming paradigm, sometimes counter-intuitevly.

### There are a couple of ways in which we may assert our data in elixir:

* By explicitly using pattern matching with `=`.
* `case` statements and family to match multiple shapes of the same data.
* By using boolean logic with `and`, `or`, `not`.
* By using thruthy logic with `&&`, `||`, `!`.
* By matching with regular expressions.

We could combine the techniques above for more powerful checks:

* By using `predicates` (functions that return either `true` or `false`).
* By using `Bitwise` operators and then matching on a result.
* By using the `match?/2` macro.
* By using the `Regex.match?/2` function.

Ways to return errros:

* rescue
* aggregatting error messages

Must track internal runtime errors for raised errors inside anonymous functions.

<!-- livebook:{"break_markdown":true} -->

### Shaping a generic contract checker

A combination of match and predicates can be a powerful tool for checking our data in a contract-like fashion, however there are a lot of patterns we might use or follow; It would be nice if we also had a unique construct for contract checking.

We might try something more universal like a predicate checker function:

```elixir
# A generic checker function may help us unify our assertions
check = fn data, predicate, error_message ->
  if predicate.(data),
    do: :ok,
    else: raise(error_message)
end

# Translate our previous handlers to predicate logic
person? = fn user -> match?(%{of_type: :person, name: _, age: _}, user) end
old_enough? = fn %{age: age} -> age > 18 end
starts_with_r? = fn %{name: name} -> String.starts_with?(name, ["R", "r"]) end

# Previous functions would map more or less like
user = %{name: "Ramiro", age: 22, of_type: :person}

:ok = check.(user, person?, "must be a map of type person")
:ok = check.(user, old_enough?, "must be old enough")
:ok = check.(user, starts_with_r?, "name must start with the letter R")
"The user is :ok!"
```

Our checker now looks a bit more declarative predicate and error come up paired along, making it 
a bit easier to understand at first glance, as a nice bonus handler logic was reduced to plain 
functions.

However not all is good, moving the checker to the predicate world limited the richness of error 
messages that previous handler logic gave us, we're also reducing performance by switching 
efficient match functions for predicates.

Performance I may live without, but I miss having specific to the point error messages.

<!-- livebook:{"break_markdown":true} -->

#### Complex errors

Instead of relying on `true | false` predicates, we might want to do our own matcher approach:

```elixir
# A generic checker function may help us unify our assertions
check? = fn data, predicate, error_message ->
  if predicate.(data),
    do: :ok,
    else: raise(error_message)
end

# This checker matches on the passed function
check! = fn data, matcher ->
  case matcher.(data) do
    :ok -> :ok
    error when is_binary(error) -> raise error
  end
end

checker_shape = fn
  %{of_type: :person, name: _, age: _} -> :ok
  %{of_type: _} -> "sorry, you must be a person"
  %{} -> "must contain the keys name, age, of_type"
  _ -> "bad input"
end

old_enough? = fn %{age: age} -> age > 18 end
starts_with_r? = fn %{name: name} -> String.starts_with?(name, ["R", "r"]) end

# Previous functions would map more or less like
user = %{name: "Ramiro", age: 22, of_type: :person}

:ok = check!.(user, checker_shape)
:ok = check?.(user, old_enough?, "must be old enough")
:ok = check?.(user, starts_with_r?, "name must start with the letter R")
"The user is :ok!"
```

Which... isn't an improvement over the previous initial approach above... while its nice that 
we ditched the explicit `raise` in each checker, it also feels like we went 2 steps forward and
1 step backward.

<!-- livebook:{"break_markdown":true} -->

.We don't necessarilly pair up our predicates and error messages in such a limited fashion, by
applying a data-first approach we might be able to still have a nice spec.

```elixir
check = fn data, specs ->
  for {predicate, error_message} <- specs do
    unless predicate.(data), do: raise(error_message)
  end

  :ok
end

# Here each element of the array represents a spec record 
# composed of a {checker function, "error_message"}
spec = [
  {&match?(%{of_type: :person}, &1), "sorry, must be of person type"},
  {& &1.age, "must have the age field"},
  {& &1.name, "must have the name field"},
  {&(&1.age > 18), "must be old enough"},
  {&String.starts_with?(&1.name, ["R", "r"]), "name must start with the letter R"}
]

user = %{name: "Ramiro", age: 20, of_type: :person}
check.(user, spec)
```

```elixir
check = fn data, specs ->
  errors =
    for {predicate, error_message} <- specs, reduce: [] do
      errors ->
        if predicate.(data),
          do: errors,
          else: [error_message | errors]
    end

  case errors do
    [] ->
      :ok

    errors when is_list(errors) ->
      errors = Enum.reverse(errors)

      raise """
      Data doesn't conform to desired specification:
      #{errors |> Enum.map(&("- " <> &1)) |> Enum.intersperse("\n")}

      Given data:
      #{inspect(data)}
      """
  end
end
```

```elixir
# Here each element of the array represents a spec record 
# composed of a {checker function, "error_message"}
spec = [
  {&match?(%{of_type: :person}, &1), "sorry, must be of person type"},
  {& &1[:age], "must have the age field"},
  {& &1[:name], "must have the name field"},
  {&(&1[:age] > 18), "must be old enough"},
  {&String.starts_with?(&1.name, ["R", "r"]), "name must start with the letter R"}
]

user = %{name: "Amiro", age: 16, of_type: :dog}
check.(user, spec)
```

```elixir
check = fn data, specs ->
  errors =
    for {bind, predicate, error_message} <- specs, reduce: [] do
      errors ->
        cond do
          !data[bind] ->
            error_message = "expected #{inspect(bind)} to be binded to the spec"
            [error_message | errors]

          !predicate.(data) ->
            [error_message | errors]

          true ->
            errors
        end
    end

  case errors do
    [] ->
      :ok

    errors when is_list(errors) ->
      errors =
        errors
        |> Enum.reverse()
        |> Enum.map(&("- " <> &1))
        |> Enum.intersperse("\n")

      data =
        data
        |> Enum.map(fn {k, v} -> "#{k}: #{inspect(v)}" end)
        |> Enum.intersperse("\n")

      raise """
      Data doesn't conform to desired specification:
      #{errors}

      Evaluated data:
      #{data}
      """
  end
end

# bind example
spec = [
  {:tickets, &(&1 >= 1), "sorry, must be at least 1 ticket"},
  {:profile, &(&1[:age] && &1[:age] > 18), "sorry must be old enough"},
  {:profile, &(&1[:name] && Regex.match?(~r/[AEIOUaeiou]/, &1[:name])),
   "must contain 1 aeiou vowel"}
]

data_bind = %{
  # tickets: 2,
  profile: %{
    # age: 18,
    name: "Javier"
  }
}

check.(data_bind, spec)
```

```elixir
defmodule Pow do
  def squared(value), do: value * value
end

ExUnit.start(autorun: false)

defmodule PowTest do
  use ExUnit.Case

  test "Result is a squared number" do
    assert is_number(Pow.squared(5))
    assert Pow.squared(3) == 9
  end

  test "Result is always a positive number" do
    x = Enum.shuffle(-100..100) |> List.first()
    assert Pow.squared(x) >= 0
  end

  test "Cannot pass wrong params" do
    assert_raise ArithmeticError, ~s(bad argument in arithmetic expression), fn ->
      Pow.squared("ten")
    end
  end
end

ExUnit.run()

defmodule VerifiedPow do
  use ExUnit.Case

  def squared(value) do
    assert is_number(value)

    result = value * value

    assert result >= 0
    assert is_number(result)

    result
  end
end
```

## Shaping a generic contract checker

```elixir
# A generic checker function may help us unify our assertions
check = fn data, predicate, error_message ->
  if predicate.(data),
    do: :ok,
    else: raise(error_message)
end

# Translate our previous handlers to predicate logic
person? = fn user -> match?(%{of_type: :person, name: _, age: _}, user) end
old_enough? = fn %{age: age} -> age > 18 end
starts_with_r? = fn %{name: name} -> String.starts_with?(name, ["R", "r"]) end

# Previous functions would map more or less like
user = %{name: "Ramiro", age: 22, of_type: :person}

:ok = check.(user, person?, "must be a map of type person")
:ok = check.(user, old_enough?, "must be old enough")
:ok = check.(user, starts_with_r?, "name must start with the letter R")
"The user is :ok!"
```

Our checker now looks a bit more declarative predicate and error come up paired along, making it 
a bit easier to understand at first glance, as a nice bonus handler logic was reduced to plain 
functions.

However not all is good, moving the checker to the predicate world limited the richness of error 
messages that previous handler logic gave us, we're also reducing performance by switching 
efficient match functions for predicates.

Performance I may live without, but I miss having specific to the point error messages.

<!-- livebook:{"break_markdown":true} -->

#### Complex errors

Instead of relying on `true | false` predicates, we might want to do our own matcher approach:

```elixir
# A generic checker function may help us unify our assertions
check? = fn data, predicate, error_message ->
  if predicate.(data),
    do: :ok,
    else: raise(error_message)
end

# This checker matches on the passed function
check! = fn data, matcher ->
  case matcher.(data) do
    :ok -> :ok
    error when is_binary(error) -> raise error
  end
end

checker_shape = fn
  %{of_type: :person, name: _, age: _} -> :ok
  %{of_type: _} -> "sorry, you must be a person"
  %{} -> "must contain the keys name, age, of_type"
  _ -> "bad input"
end

old_enough? = fn %{age: age} -> age > 18 end
starts_with_r? = fn %{name: name} -> String.starts_with?(name, ["R", "r"]) end

# Previous functions would map more or less like
user = %{name: "Ramiro", age: 22, of_type: :person}

:ok = check!.(user, checker_shape)
:ok = check?.(user, old_enough?, "must be old enough")
:ok = check?.(user, starts_with_r?, "name must start with the letter R")
"The user is :ok!"
```

Which... isn't an improvement over the previous initial approach above... while its nice that 
we ditched the explicit `raise` in each checker, it also feels like we went 2 steps forward and
1 step backward.

<!-- livebook:{"break_markdown":true} -->

.We don't necessarilly pair up our predicates and error messages in such a limited fashion, by
applying a data-first approach we might be able to still have a nice spec.

```elixir
check = fn data, specs ->
  for {predicate, error_message} <- specs do
    unless predicate.(data), do: raise(error_message)
  end

  :ok
end

# Here each element of the array represents a spec record 
# composed of a {checker function, "error_message"}
spec = [
  {&match?(%{of_type: :person}, &1), "sorry, must be of person type"},
  {& &1.age, "must have the age field"},
  {& &1.name, "must have the name field"},
  {&(&1.age > 18), "must be old enough"},
  {&String.starts_with?(&1.name, ["R", "r"]), "name must start with the letter R"}
]

user = %{name: "Ramiro", age: 20, of_type: :person}
check.(user, spec)
```

```elixir
check = fn data, specs ->
  errors =
    for {predicate, error_message} <- specs, reduce: [] do
      errors ->
        if predicate.(data),
          do: errors,
          else: [error_message | errors]
    end

  case errors do
    [] ->
      :ok

    errors when is_list(errors) ->
      errors = Enum.reverse(errors)

      raise """
      Data doesn't conform to desired specification:
      #{errors |> Enum.map(&("- " <> &1)) |> Enum.intersperse("\n")}

      Given data:
      #{inspect(data)}
      """
  end
end
```

```elixir
# Here each element of the array represents a spec record 
# composed of a {checker function, "error_message"}
spec = [
  {&match?(%{of_type: :person}, &1), "sorry, must be of person type"},
  {& &1[:age], "must have the age field"},
  {& &1[:name], "must have the name field"},
  {&(&1[:age] > 18), "must be old enough"},
  {&String.starts_with?(&1.name, ["R", "r"]), "name must start with the letter R"}
]

user = %{name: "Amiro", age: 16, of_type: :dog}
check.(user, spec)
```

```elixir
check = fn data, specs ->
  errors =
    for {bind, predicate, error_message} <- specs, reduce: [] do
      errors ->
        cond do
          !data[bind] ->
            error_message = "expected #{inspect(bind)} to be binded to the spec"
            [error_message | errors]

          !predicate.(data) ->
            [error_message | errors]

          true ->
            errors
        end
    end

  case errors do
    [] ->
      :ok

    errors when is_list(errors) ->
      errors =
        errors
        |> Enum.reverse()
        |> Enum.map(&("- " <> &1))
        |> Enum.intersperse("\n")

      data =
        data
        |> Enum.map(fn {k, v} -> "#{k}: #{inspect(v)}" end)
        |> Enum.intersperse("\n")

      raise """
      Data doesn't conform to desired specification:
      #{errors}

      Evaluated data:
      #{data}
      """
  end
end

# bind example
spec = [
  {:tickets, &(&1 >= 1), "sorry, must be at least 1 ticket"},
  {:profile, &(&1[:age] && &1[:age] > 18), "sorry must be old enough"},
  {:profile, &(&1[:name] && Regex.match?(~r/[AEIOUaeiou]/, &1[:name])),
   "must contain 1 aeiou vowel"}
]

data_bind = %{
  # tickets: 2,
  profile: %{
    # age: 18,
    name: "Javier"
  }
}

check.(data_bind, spec)
```

## Avoid mapping logic or transformations

## contracts 3

### In previous article...

#### The example

### Contract programming concepts

#### Pre-conditions

<!-- livebook:{"break_markdown":true} -->

##### What about guards?

<!-- livebook:{"break_markdown":true} -->

#### Post-conditions

<!-- livebook:{"break_markdown":true} -->

#### Invariants

Run-time concern of the component we're testing, tracking the value of a binded variable in
Elixir would be costly and the immutable aspect of Elixir makes it somewhat hard.

We could track it in a GenServer and that may have its purposes but it would be over-kill for 
what we need.

In elixir we can use functional programming and our previous 2 concepts to mantain consistency
our variables, lets say that we need to loop through some code and have some guarantees in
that loop; we might as well use a pre-condition and post-condition at the function level.

## Examples

```elixir
ExUnit.start(autorun: false)

defmodule Program do
  use ExUnit.Case

  @doc "Prints the given values in fraction form ⁰⁄₁"
  @spec fraction(String.t(), String.t()) :: String.t()
  def fraction(numerator, denominator) do
    sup = for <<x <- to_string(numerator)>>, into: "", do: superscript(x)
    sub = for <<x <- to_string(denominator)>>, into: "", do: subscript(x)
    IO.chardata_to_string([sup, "⁄", sub])
  end

  defp superscript(value) do
    case value do
      ?1 -> "¹"
      ?2 -> "²"
      ?3 -> "³"
      value -> <<226, 129, 176 + (value - ?0)>>
    end
  end

  defp subscript(value) do
    <<226, 130, 128 + (value - ?0)>>
  end

  test "transforms to fraction form" do
    assert fraction("0123456789", "9876543210") == "⁰¹²³⁴⁵⁶⁷⁸⁹⁄₉₈₇₆₅₄₃₂₁₀"
  end
end

ExUnit.run()
```


### We can do invariants by

Is a construct that checks for assertions during the lifetime of a process, as elixir is a functional language and structures and function don't necessarily have a runtime aspect to them, one way of doing invariants is checking values both at the beginning and end of execution, more or less like:

* pre-condition
* invariant
* process
* invariant
* post-condition

We could always check the invariant on each binded variable, but this would probably become very complex and costly.

Whoever, different types of process may not follow the logic stated above.

* By adding an assertion at any point in the function's lifetime, this assertion becomes an invariant that is checked in a single place in time.
* By adding the same assertion at the beginning and end of a function's lifetime, this becomes an invariant that checks the function "thorough its lifetime".
* A construct that checks 
* By dividing and conquer each invariant into its own method with a pre-condition and a post-condition.
* Loop invariants could be added during the loop, a custom function with a passing. 
* Structure invariants would be equivalent to schema invariants constructor methods, check params, check output.
* Invariants excel at entities that have a runtime, like a process or a GenServer, we could have constants through the whole life-cycle.
* We can always relax requirements for an invariant by having the right datastructure and substituitin it with logic. A funny aspect of the `for` construct in elixir is that it implicitly relaxes requirements when we match for a field, not by crashing but by filtering.

Notes:

* Video son invariants
* LISKOV
* Hoare Logic
* Wikipedia's article on assertion and Hoare

So far the planned topics are:
Part 1 - Introduction to Contract Programming
Part 2 - Assertion Primitives
Part 3 - Concepts, Preconditions, Postconditions and Invariants
Part 4 - Building a simple "checker" function
Part 5 - Beyond assertions, how far can we get?
