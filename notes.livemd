# Untitled noteboIn ok

## Notes

### Assertions

An assertion in the context of contract programming or data verification my be synonimous
with check, property or even a test.

When the assertion works as desired we continue with the flow of data, otherwise when data
fails to comply to the assertion we "fail" the process.

There are many mechanisms that may mimick assertions in elixir, some of them are more cathered 
towards program flow but all may be composed into assertions:

* Raising an error with `raise "message"` or `raise CustomExceptionError`
* Returning an `:error` atom or an `{:error, "message"}` tuple.
* Returning a structure `CustomError` or exception structure `CustomExceptionError` as data.
* Using the `assert` keyword through the `ExUnit` test framework.

There are as well many mechanisms for control flow which will aid us in error handling,
while the point of an assertion is not necessarily to introduce control flow, these
will help us to build complex functionality:

* Pattern matching on data with multiple shapes `case` or function headers.
* Using predicates along the `if` and `cond` macros.
* Composition of complex return values via the `with` clause macro.
* Error handling via the `try` clause or the `rescue` keyword at the function level.
* Error handling through processes signals.

Note, this tutorial is not meant to teach or offer advise on how to use the above constructs;
the real semantics of the above may have other roots but this series tries to exploit them 
in a way that works along the Contract Programming paradigm, sometimes counter-intuitevly.

<!-- livebook:{"break_markdown":true} -->

Or composing it with an elixir construct that drives the logic forward:

```elixir
user = %{name: "Raúl", age: 17, of_type: :person}

with :ok <- check_shape.(user),
     :ok <- check_old_enough.(user),
     :ok <- check_starts_with_r.(user),
     do: "The user is :ok!"
```

A combination of match and predicates can be a powerful tool for checking our data in a contract-like fashion, however there are a lot of patterns we might use or follow; It would be nice if we also had a unique construct for contract checking.

### Shaping a generic contract checker

We might try something more universal like a predicate checker function:

```elixir
# A generic checker function may help us unify our assertions
check = fn data, predicate, error_message ->
  if predicate.(data),
    do: :ok,
    else: raise(error_message)
end

# Translate our previous handlers to predicate logic
person? = fn user -> match?(%{of_type: :person, name: _, age: _}, user) end
old_enough? = fn %{age: age} -> age > 18 end
starts_with_r? = fn %{name: name} -> String.starts_with?(name, ["R", "r"]) end

# Previous functions would map more or less like
user = %{name: "Ramiro", age: 22, of_type: :person}

:ok = check.(user, person?, "must be a map of type person")
:ok = check.(user, old_enough?, "must be old enough")
:ok = check.(user, starts_with_r?, "name must start with the letter R")
"The user is :ok!"
```

Our checker now looks a bit more declarative predicate and error come up paired along, making it 
a bit easier to understand at first glance, as a nice bonus handler logic was reduced to plain 
functions.

However not all is good, moving the checker to the predicate world limited the richness of error 
messages that previous handler logic gave us, we're also reducing performance by switching 
efficient match functions for predicates.

Performance I may live without, but I miss having specific to the point error messages.

<!-- livebook:{"break_markdown":true} -->

#### Complex errors

Instead of relying on `true | false` predicates, we might want to do our own matcher approach:

```elixir
# A generic checker function may help us unify our assertions
check? = fn data, predicate, error_message ->
  if predicate.(data),
    do: :ok,
    else: raise(error_message)
end

# This checker matches on the passed function
check! = fn data, matcher ->
  case matcher.(data) do
    :ok -> :ok
    error when is_binary(error) -> raise error
  end
end

checker_shape = fn
  %{of_type: :person, name: _, age: _} -> :ok
  %{of_type: _} -> "sorry, you must be a person"
  %{} -> "must contain the keys name, age, of_type"
  _ -> "bad input"
end

old_enough? = fn %{age: age} -> age > 18 end
starts_with_r? = fn %{name: name} -> String.starts_with?(name, ["R", "r"]) end

# Previous functions would map more or less like
user = %{name: "Ramiro", age: 22, of_type: :person}

:ok = check!.(user, checker_shape)
:ok = check?.(user, old_enough?, "must be old enough")
:ok = check?.(user, starts_with_r?, "name must start with the letter R")
"The user is :ok!"
```

Which... isn't an improvement over the previous initial approach above... while its nice that 
we ditched the explicit `raise` in each checker, it also feels like we went 2 steps forward and
1 step backward.

<!-- livebook:{"break_markdown":true} -->

.We don't necessarilly pair up our predicates and error messages in such a limited fashion, by
applying a data-first approach we might be able to still have a nice spec.

```elixir
check = fn data, specs ->
  for {predicate, error_message} <- specs do
    unless predicate.(data), do: raise(error_message)
  end

  :ok
end

# Here each element of the array represents a spec record 
# composed of a {checker function, "error_message"}
spec = [
  {&match?(%{of_type: :person}, &1), "sorry, must be of person type"},
  {& &1.age, "must have the age field"},
  {& &1.name, "must have the name field"},
  {&(&1.age > 18), "must be old enough"},
  {&String.starts_with?(&1.name, ["R", "r"]), "name must start with the letter R"}
]

user = %{name: "Ramiro", age: 20, of_type: :person}
check.(user, spec)
```

```elixir
check = fn data, specs ->
  errors =
    for {predicate, error_message} <- specs, reduce: [] do
      errors ->
        if predicate.(data),
          do: errors,
          else: [error_message | errors]
    end

  case errors do
    [] ->
      :ok

    errors when is_list(errors) ->
      errors = Enum.reverse(errors)

      raise """
      Data doesn't conform to desired specification:
      #{errors |> Enum.map(&("- " <> &1)) |> Enum.intersperse("\n")}

      Given data:
      #{inspect(data)}
      """
  end
end
```

```elixir
# Here each element of the array represents a spec record 
# composed of a {checker function, "error_message"}
spec = [
  {&match?(%{of_type: :person}, &1), "sorry, must be of person type"},
  {& &1[:age], "must have the age field"},
  {& &1[:name], "must have the name field"},
  {&(&1[:age] > 18), "must be old enough"},
  {&String.starts_with?(&1.name, ["R", "r"]), "name must start with the letter R"}
]

user = %{name: "Amiro", age: 16, of_type: :dog}
check.(user, spec)
```

<!-- livebook:{"livebook_object":"cell_input","name":"input","type":"text","value":""} -->

```elixir
check = fn data, specs ->
  errors =
    for {bind, predicate, error_message} <- specs, reduce: [] do
      errors ->
        cond do
          !data[bind] ->
            error_message = "expected #{inspect(bind)} to be binded to the spec"
            [error_message | errors]

          !predicate.(data) ->
            [error_message | errors]

          true ->
            errors
        end
    end

  case errors do
    [] ->
      :ok

    errors when is_list(errors) ->
      errors =
        errors
        |> Enum.reverse()
        |> Enum.map(&("- " <> &1))
        |> Enum.intersperse("\n")

      data =
        data
        |> Enum.map(fn {k, v} -> "#{k}: #{inspect(v)}" end)
        |> Enum.intersperse("\n")

      raise """
      Data doesn't conform to desired specification:
      #{errors}

      Evaluated data:
      #{data}
      """
  end
end

# bind example
spec = [
  {:tickets, &(&1 >= 1), "sorry, must be at least 1 ticket"},
  {:profile, &(&1[:age] && &1[:age] > 18), "sorry must be old enough"},
  {:profile, &(&1[:name] && Regex.match?(~r/[AEIOUaeiou]/, &1[:name])),
   "must contain 1 aeiou vowel"}
]

data_bind = %{
  # tickets: 2,
  profile: %{
    # age: 18,
    name: "Javier"
  }
}

check.(data_bind, spec)
```

Must track internal runtime errors for raised errors inside anonymous functions.

<!-- livebook:{"break_markdown":true} -->

There are a couple of ways in which we may assert our data in elixir:

* By explicitly using pattern matching with `=`.
* `case` statements and family to match multiple shapes of the same data.
* By using boolean logic with `and`, `or`, `not`.
* By using thruthy logic with `&&`, `||`, `!`.
* By matching with regular expressions.

We could combine the techniques above for more powerful checks:

* By using `predicates` (functions that return either `true` or `false`).
* By using `Bitwise` operators and then matching on a result.
* By using the `match?/2` macro.
* By using the `Regex.match?/2` function.

Ways to return errros:

* rescue
* aggregatting error messages

<!-- livebook:{"break_markdown":true} -->

How to check one-off contract.

<!-- livebook:{"break_markdown":true} -->

Tests are independent from the component they check from outside while a contract is embedded
in it and can introspect the whole lifecycle of the component and not only the outside layers.

<!-- livebook:{"break_markdown":true} -->

### Dependent checks

### Single interface a macro shell

```elixir
ExUnit.start(autorun: false)

defmodule Program do
  use ExUnit.Case

  @doc "Prints the given values in fraction form ⁰⁄₁"
  def fraction(numerator, denominator) do
    # Map each digit to their corresponding super and sub string representation
    sup = for <<x <- to_string(numerator)>>, into: "", do: <<226, 129, 176 + (x - ?0)>>
    sub = for <<x <- to_string(denominator)>>, into: "", do: <<226, 130, 128 + (x - ?0)>>
    IO.chardata_to_string([sup, "⁄", sub])
  end

  test "transforms to fraction form" do
    assert fraction(48, 6) == "⁴⁸⁄₆"
    assert fraction(8, 20) == "⁸⁄₂₀"
  end
end

ExUnit.run()
```

```elixir
defmodule Pow do
  def squared(value), do: value * value
end

ExUnit.start(autorun: false)

defmodule PowTest do
  use ExUnit.Case

  test "Result is a squared number" do
    assert is_number(Pow.squared(5))
    assert Pow.squared(3) == 9
  end

  test "Result is always a positive number" do
    x = Enum.shuffle(-100..100) |> List.first()
    assert Pow.squared(x) >= 0
  end

  test "Cannot pass wrong params" do
    assert_raise ArithmeticError, ~s(bad argument in arithmetic expression), fn ->
      Pow.squared("ten")
    end
  end
end

ExUnit.run()

defmodule VerifiedPow do
  use ExUnit.Case

  def squared(value) do
    assert is_number(value)

    result = value * value

    assert result >= 0
    assert is_number(result)

    result
  end
end
```

## Contract Programming an Elixir approach

### Programming by contract?

Is an approach to verification that relies on the succesful execution of our statements;
to verify the program we run a series of assertions not much different to what we 
do with [ExUnit](https://hexdocs.pm/ex_unit/ExUnit.html) when testing:

```elixir
ExUnit.start(autorun: false)

defmodule Program do
  def sum_all(numbers), do: Enum.sum(numbers)

  use ExUnit.Case

  test "Sums a bunch of numbers" do
    assert sum_all(0..10) == 55
    assert sum_all([-10, -5, 0, 5, 10]) == 0
    assert sum_all([0, 0.25, 0.5, 0.75, 1]) == 2.5

    assert_raise ArithmeticError, ~s(bad argument in arithmetic expression), fn ->
      sum_all(["zero", "ten"])
    end

    assert_raise Protocol.UndefinedError,
                 ~s(protocol Enumerable not implemented for "1 2 3" of type BitString),
                 fn -> sum_all("1 2 3") end
  end
end

ExUnit.run()
```

In the example above we're taking `Program.sum_all/1` checking that it meets the input and output 
expectations, in a sense this style of verification observes our function component only from the 
outside.

<!-- livebook:{"break_markdown":true} -->

Contract programming differs in that our assertions go embedded inside the components of our
system, for example lets set some deal or break expectations to the `Program.sum_all/1` function:

```elixir
defmodule Program do
  def sum_all(numbers) do
    # Assert that our initial input is a list
    is_list(numbers) || is_struct(numbers, Range) ||
      raise "Passed in parameter must be a list or range"

    result =
      Enum.reduce(numbers, 0, fn number, accumulator ->
        # Assert that each value in the list is numeric
        is_number(number) || raise "Element #{inspect(number)} is not a number"
        accumulator + number
      end)

    # Assert that resulting value is numeric
    is_number(result) || raise "Result didn't return a number got #{inspect(result)}"
    result
  end
end
```

The code got a bit more verbose but hopefully we're now able to extract clearer errors just by
running the function:

```elixir
Program.sum_all("1 2 3")
```

```elixir
Program.sum_all(["zero", "ten"])
```

With this kind of verification the focus also shifted a little, rather than only checking 
input/output we're now more interested in limiting the domain and range of our function; 
when something unexpected happens we halt the program and try to give a reasonable error
this is how the concept of "contracts" work in a very basic sense.

<!-- livebook:{"break_markdown":true} -->

We may even test the function component as we did before, just notice how our contracts 
changed the expectations for `assert_raise` with the custom errors we defined:

```elixir
ExUnit.start(autorun: false)

defmodule ProgramTest do
  use ExUnit.Case

  test "Sums a bunch of numbers" do
    assert Program.sum_all(0..10) == 55
    assert Program.sum_all([-10, -5, 0, 5, 10]) == 0
    assert Program.sum_all([0, 0.25, 0.5, 0.75, 1]) == 2.5

    assert_raise RuntimeError, ~s(Element "zero" is not a number), fn ->
      Program.sum_all(["zero", "ten"])
    end

    assert_raise RuntimeError, ~s(Passed in parameter must be a list or range), fn ->
      Program.sum_all("1 2 3")
    end
  end
end

ExUnit.run()
```

### Assertions

An assertion in the context of contract programming or data verification my be synonimous
with check, property or even a test.

When the assertion works as desired we continue with the flow of data, otherwise when data
fails to comply to the assertion we "fail" the process.

There are many mechanisms that may mimick assertions in elixir, some of them are more cathered 
towards program flow but all may be composed into assertions:

* Raising an error with `raise "message"` or `raise CustomExceptionError`
* Returning an `:error` atom or an `{:error, "message"}` tuple.
* Returning a structure `CustomError` or exception structure `CustomExceptionError` as data.
* Using the `assert` keyword through the `ExUnit` test framework.

There are as well many mechanisms for control flow which will aid us in error handling,
while the point of an assertion is not necessarily to introduce control flow, these
will help us to build complex functionality:

* Pattern matching on data with multiple shapes `case` or function headers.
* Using predicates along the `if` and `cond` macros.
* Composition of complex return values via the `with` clause macro.
* Error handling via the `try` clause or the `rescue` keyword at the function level.
* Error handling through processes signals.

Note, this tutorial is not meant to teach or offer advise on how to use the above constructs;
the real semantics of the above may have other roots but this series tries to exploit them 
in a way that works along the Contract Programming paradigm, sometimes counter-intuitevly.

### Assertion primitives - Pattern Matching

We generally use assertions to prove properties around our data, for example lets introduce
the _address_ datatype which we may represent as:

```elixir
address =
  {:address, "Mexico", "Baja California", "Tijuana", "22402", "Pacific Hills, Central Park"}
```

In this context, an address is represented by a 6 record tuple denoting the 
type, country, state, city, postal code, and written address in that order.

Our codebase may manipulate this type very differently depending on the context, but how can we
guarantee that the binded variable above `address` has the properties we look for? Basic pattern
matching might give us a way:

```elixir
# Guarantee that the data is of the right size
{_, _, _, _, _, _} = address

# Guarantee that first record is always `:address`
{:address, _, _, _, _, _} = address
```

If we run the above checks with a missing written address:

```elixir
bad_address = {:address, "Mexico", "Baja California", "Tijuana", "22402"}

# Guarantee that the data is of the right size
{_, _, _, _, _, _} = bad_address

# Guarantee that first record is always `:address`
{:address, _, _, _, _, _} = bad_address
```

Our match fails at first check, it cannot bind a 5 record tuple to the 6 record shape, the 
behaviour of the match is then to raise a `MatchError` exception, halting the program.

But we don't always need to be so strict with our data, maybe missing a field should not be the
end of the world for our programs.

### Pattern Matching - Optionality

Sometimes, we just don't want to handle a single representation for our data, we know there may
be multiple forms of correct data as well as multiple ways in which it can fail; we may use some 
of the control flow mechanisms in elixir to handle optionality.

```elixir
address = {:address, "México", "Baja California", "Tijuana", "22402"}

case address do
  # Guarantee that the data is of the right size and its type :address
  {:address, _, _, _, _, _} ->
    :ok

  # Guarantee that the data is of the right size and its type :address
  {:address, _, _, _, _} ->
    :ok

  # Any other shape is considered an error
  _other ->
    raise "not a valid address record: #{inspect(address)}"
end
```

Lets convert the above to a function so we may reuse it for other cases:

```elixir
check_address = fn
  {:address, _, _, _, _, _} -> :ok
  {:address, _, _, _, _} -> :ok
  other -> raise "not a valid address record: #{inspect(other)}"
end
```

A 6 digit address record should be no issue for our checker:

```elixir
address =
  {:address, "Mexico", "Baja California", "Tijuana", "22402", "Pacific Hills, Central Park"}

:ok = check_address.(address)
```

A 5 digit address record is now also valid:

```elixir
address = {:address, "Mexico", "Baja California", "Tijuana", "22402"}

:ok = check_address.(address)
```

This form of optional checks also gives us the chance to introduce our own custom errors, 
a bad shape will raise:

```elixir
# Finally, a bad type or shape will raise an error
address = {:addr, "Mexico", "Baja California", "Tijuana"}

:ok = check_address.(address)
```

We however made a tradeoff, we went from having separate assertions of our data to having a single
compound checker, so we may see the above more of a single data handler than a set of properties,
if we wanted to check for different properties in another function or context, we would re-write 
our checker again.

```elixir

```

```elixir
check_address = fn address ->
  case address do
    {:address, _, _, _, _, _} ->
      :ok

    {:address, _, _, _, _} ->
      :ok

    _other ->
      raise "not a valid address record: #{address}"
  end
end

# A 6 record address We consider an addresHere we have a 
ok_address =
  {:address, "Mexico", "Baja California", "Tijuana", "22402", "Pacific Hills, Central Park"}

error_address_1 =
  {:address, "Méjico", "Baja California", "Tijuana", "22402", "Pacific Hills, Central Park"}

error_address_2 = {:direccion, ""}
```

### Primitive forms of a contract system in elixir

We may use the match operator to check for the data "shape".

```elixir
user = %{name: "Raúl", age: 32, of_type: :person}
```

A good match will just give use the data back.

```elixir
%{of_type: :person} = user
```

But a bad shape will raise a `MatchError`.

```elixir
%{of_type: :name} = user
```

Matches are great but limited, predicate functions give us more flexibility on the properties we want to check in our data.

```elixir
# This check only needs of match expressions
check_shape = fn
  %{of_type: :person, name: _, age: _} ->
    :ok

  %{of_type: _} ->
    raise "sorry, you must be a person"

  %{} ->
    raise "must contain the keys name, age, of_type"

  _ ->
    raise "bad input"
end

# This one may be a match or an expression, but match is good enough
check_old_enough = fn
  %{age: age} when age > 18 -> :ok
  %{age: _age} -> raise "must be old enough"
end

# This gets hard to do with match only, so we go for conditional logic
check_starts_with_r = fn %{name: name} ->
  if String.starts_with?(name, ["R", "r"]),
    do: :ok,
    else: raise("name must start with the letter R")
end
```

Then checking a user is just a matter of passing through our checkers:

```elixir
:ok = check_shape.(user)
:ok = check_old_enough.(user)
:ok = check_starts_with_r.(user)
"The user is :ok!"
```

Or composing it with an elixir construct that drives the logic forward:

```elixir
user = %{name: "Raúl", age: 17, of_type: :person}

with :ok <- check_shape.(user),
     :ok <- check_old_enough.(user),
     :ok <- check_starts_with_r.(user),
     do: "The user is :ok!"
```

```elixir
user = %{name: "Saúl", age: 21, of_type: :person}

with :ok <- check_shape.(user),
     :ok <- check_old_enough.(user),
     :ok <- check_starts_with_r.(user),
     do: "The user is :ok!"
```

```elixir
user = %{name: "Rohan", age: 22, of_type: :person}

with :ok <- check_shape.(user),
     :ok <- check_old_enough.(user),
     :ok <- check_starts_with_r.(user),
     do: "The user is :ok!"
```

A combination of match and predicates can be a powerful tool for checking our data in a contract-like fashion, however there are a lot of patterns we might use or follow; It would be nice if we also had a unique construct for contract checking.

### Shaping a generic contract checker

We might try something more universal like a predicate checker function:

```elixir
# A generic checker function may help us unify our assertions
check = fn data, predicate, error_message ->
  if predicate.(data),
    do: :ok,
    else: raise(error_message)
end

# Translate our previous handlers to predicate logic
person? = fn user -> match?(%{of_type: :person, name: _, age: _}, user) end
old_enough? = fn %{age: age} -> age > 18 end
starts_with_r? = fn %{name: name} -> String.starts_with?(name, ["R", "r"]) end

# Previous functions would map more or less like
user = %{name: "Ramiro", age: 22, of_type: :person}

:ok = check.(user, person?, "must be a map of type person")
:ok = check.(user, old_enough?, "must be old enough")
:ok = check.(user, starts_with_r?, "name must start with the letter R")
"The user is :ok!"
```

Our checker now looks a bit more declarative predicate and error come up paired along, making it 
a bit easier to understand at first glance, as a nice bonus handler logic was reduced to plain 
functions.

However not all is good, moving the checker to the predicate world limited the richness of error 
messages that previous handler logic gave us, we're also reducing performance by switching 
efficient match functions for predicates.

Performance I may live without, but I miss having specific to the point error messages.

<!-- livebook:{"break_markdown":true} -->

#### Complex errors

Instead of relying on `true | false` predicates, we might want to do our own matcher approach:

```elixir
# A generic checker function may help us unify our assertions
check? = fn data, predicate, error_message ->
  if predicate.(data),
    do: :ok,
    else: raise(error_message)
end

# This checker matches on the passed function
check! = fn data, matcher ->
  case matcher.(data) do
    :ok -> :ok
    error when is_binary(error) -> raise error
  end
end

checker_shape = fn
  %{of_type: :person, name: _, age: _} -> :ok
  %{of_type: _} -> "sorry, you must be a person"
  %{} -> "must contain the keys name, age, of_type"
  _ -> "bad input"
end

old_enough? = fn %{age: age} -> age > 18 end
starts_with_r? = fn %{name: name} -> String.starts_with?(name, ["R", "r"]) end

# Previous functions would map more or less like
user = %{name: "Ramiro", age: 22, of_type: :person}

:ok = check!.(user, checker_shape)
:ok = check?.(user, old_enough?, "must be old enough")
:ok = check?.(user, starts_with_r?, "name must start with the letter R")
"The user is :ok!"
```

Which... isn't an improvement over the previous initial approach above... while its nice that 
we ditched the explicit `raise` in each checker, it also feels like we went 2 steps forward and
1 step backward.

<!-- livebook:{"break_markdown":true} -->

.We don't necessarilly pair up our predicates and error messages in such a limited fashion, by
applying a data-first approach we might be able to still have a nice spec.

```elixir
check = fn data, specs ->
  for {predicate, error_message} <- specs do
    unless predicate.(data), do: raise(error_message)
  end

  :ok
end

# Here each element of the array represents a spec record 
# composed of a {checker function, "error_message"}
spec = [
  {&match?(%{of_type: :person}, &1), "sorry, must be of person type"},
  {& &1.age, "must have the age field"},
  {& &1.name, "must have the name field"},
  {&(&1.age > 18), "must be old enough"},
  {&String.starts_with?(&1.name, ["R", "r"]), "name must start with the letter R"}
]

user = %{name: "Ramiro", age: 20, of_type: :person}
check.(user, spec)
```

```elixir
check = fn data, specs ->
  errors =
    for {predicate, error_message} <- specs, reduce: [] do
      errors ->
        if predicate.(data),
          do: errors,
          else: [error_message | errors]
    end

  case errors do
    [] ->
      :ok

    errors when is_list(errors) ->
      errors = Enum.reverse(errors)

      raise """
      Data doesn't conform to desired specification:
      #{errors |> Enum.map(&("- " <> &1)) |> Enum.intersperse("\n")}

      Given data:
      #{inspect(data)}
      """
  end
end
```

```elixir
# Here each element of the array represents a spec record 
# composed of a {checker function, "error_message"}
spec = [
  {&match?(%{of_type: :person}, &1), "sorry, must be of person type"},
  {& &1[:age], "must have the age field"},
  {& &1[:name], "must have the name field"},
  {&(&1[:age] > 18), "must be old enough"},
  {&String.starts_with?(&1.name, ["R", "r"]), "name must start with the letter R"}
]

user = %{name: "Amiro", age: 16, of_type: :dog}
check.(user, spec)
```

<!-- livebook:{"livebook_object":"cell_input","name":"input","type":"text","value":""} -->

```elixir
check = fn data, specs ->
  errors =
    for {bind, predicate, error_message} <- specs, reduce: [] do
      errors ->
        cond do
          !data[bind] ->
            error_message = "expected #{inspect(bind)} to be binded to the spec"
            [error_message | errors]

          !predicate.(data) ->
            [error_message | errors]

          true ->
            errors
        end
    end

  case errors do
    [] ->
      :ok

    errors when is_list(errors) ->
      errors =
        errors
        |> Enum.reverse()
        |> Enum.map(&("- " <> &1))
        |> Enum.intersperse("\n")

      data =
        data
        |> Enum.map(fn {k, v} -> "#{k}: #{inspect(v)}" end)
        |> Enum.intersperse("\n")

      raise """
      Data doesn't conform to desired specification:
      #{errors}

      Evaluated data:
      #{data}
      """
  end
end

# bind example
spec = [
  {:tickets, &(&1 >= 1), "sorry, must be at least 1 ticket"},
  {:profile, &(&1[:age] && &1[:age] > 18), "sorry must be old enough"},
  {:profile, &(&1[:name] && Regex.match?(~r/[AEIOUaeiou]/, &1[:name])),
   "must contain 1 aeiou vowel"}
]

data_bind = %{
  # tickets: 2,
  profile: %{
    # age: 18,
    name: "Javier"
  }
}

check.(data_bind, spec)
```

Must track internal runtime errors for raised errors inside anonymous functions.

<!-- livebook:{"break_markdown":true} -->

How to check a dependent contract.

<!-- livebook:{"break_markdown":true} -->

There are a couple of ways in which we may assert our data in elixir:

* By explicitly using pattern matching with `=`.
* `case` statements and family to match multiple shapes of the same data.
* By using boolean logic with `and`, `or`, `not`.
* By using thruthy logic with `&&`, `||`, `!`.
* By matching with regular expressions.

We could combine the techniques above for more powerful checks:

* By using `predicates` (functions that return either `true` or `false`).
* By using `Bitwise` operators and then matching on a result.
* By using the `match?/2` macro.
* By using the `Regex.match?/2` function.

Ways to return errros:

* rescue
* aggregatting error messages

<!-- livebook:{"break_markdown":true} -->

How to check one-off contract.

<!-- livebook:{"break_markdown":true} -->

Tests are independent from the component they check from outside while a contract is embedded
in it and can introspect the whole lifecycle of the component and not only the outside layers.

<!-- livebook:{"break_markdown":true} -->



```elixir

```

### Dependent checks

### Single interface a macro shell

```elixir
ExUnit.start(autorun: false)

defmodule Program do
  use ExUnit.Case

  @doc "Prints the given values in fraction form ⁰⁄₁"
  def fraction(numerator, denominator) do
    # Map each digit to their corresponding super and sub string representation
    sup = for <<x <- to_string(numerator)>>, into: "", do: <<226, 129, 176 + (x - ?0)>>
    sub = for <<x <- to_string(denominator)>>, into: "", do: <<226, 130, 128 + (x - ?0)>>
    IO.chardata_to_string([sup, "⁄", sub])
  end

  test "transforms to fraction form" do
    assert fraction(48, 6) == "⁴⁸⁄₆"
    assert fraction(8, 20) == "⁸⁄₂₀"
  end
end

ExUnit.run()
```

## contracts 2

### In previous article...

#### The example

### Contract programming concepts

#### Pre-conditions

```elixir

```

##### What about guards?

<!-- livebook:{"break_markdown":true} -->

#### Post-conditions

<!-- livebook:{"break_markdown":true} -->

#### Invariants

Run-time concern of the component we're testing, tracking the value of a binded variable in
Elixir would be costly and the immutable aspect of Elixir makes it somewhat hard.

We could track it in a GenServer and that may have its purposes but it would be over-kill for 
what we need.

In elixir we can use functional programming and our previous 2 concepts to mantain consistency
our variables, lets say that we need to loop through some code and have some guarantees in
that loop; we might as well use a pre-condition and post-condition at the function level.

<!-- livebook:{"break_markdown":true} -->

### Notes

> In general, a developer will want to use the general `assert` macro in tests.
> The docs state that this is only "general" use of assertions but don't discard use in other contexts: https://hexdocs.pm/ex_unit/ExUnit.Assertions.html#assert/1

> Elixir provides pattern matching, which allows us to assert on the shape or extract values from data structures
> From the elixir docs: https://hexdocs.pm/elixir/patterns-and-guards.html#content

There are also other references like Elixir in Action by Sasa Juric and Programming Erlang which refer to the match operation as an assertion.

## Avoid mapping logic or transformations

## Avoid encompassing too much

A better data-structure would have helped us here, but wanted to keep example simple.
